<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>わいちゃんRUN</title>
<style>
  :root{ --bg:#0d0f13; --fg:#e7ecf3; --accent:#8dd3ff; --tile:#151a26; }
  html,body{ height:100%; margin:0; background:var(--bg); color:var(--fg); font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans JP", sans-serif; }
  .wrap{ position:fixed; inset:0; display:grid; place-items:center; }
  canvas{ width:100vw; height:100dvh; display:block; touch-action:manipulation; outline:none; }
  .sr-only{ position:absolute; left:-9999px; }
</style>
</head>
<body>
<div class="wrap">
  <canvas id="game" width="800" height="450"></canvas>
</div>
<script>
(function(){
  'use strict';

  const ASSETS = {
    penguinRun:  './走り.PNG',
    bear:        './追いかける.PNG',
    gotHit:      './襲われた.PNG',
    homeImage:   './ホーム画面.PNG'
  };

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const VW = 800, VH = 450;

  function clear(){ ctx.clearRect(0,0,canvas.width,canvas.height); }

  function drawBG(){
    const g = ctx.createLinearGradient(0,0,0,VH);
    g.addColorStop(0,'#172033');
    g.addColorStop(1,'#0c121e');
    ctx.fillStyle = g; ctx.fillRect(0,0,VW,VH);
    ctx.fillStyle = '#24304a';
    ctx.fillRect(0, groundY, VW, VH-groundY);
  }

  function loadImage(src){
    return new Promise((resolve)=>{
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = () => resolve(null);
      img.src = src;
    });
  }

  const images = { penguinRun:null, bear:null, gotHit:null, homeImage:null };

  let state = 'loading';
  let last = 0; let scroll = 0; let speed = 5; let score = 0; let lives = 3;
  const groundY = 360;

  const player = {
    x: 200,
    y: groundY - 90,
    w: 120,
    h: 90,
    vy: 0,
    onGround: true,
    stunned: false,
    stunTimer: 0,
    jump(){
      if(this.onGround && !this.stunned){
        this.vy = -14;
        this.onGround = false;
      }
    },
    update(){
      if(this.stunned){
        this.stunTimer--;
        if(this.stunTimer<=0){ this.stunned=false; }
        return;
      }
      this.vy += 0.7;
      this.y += this.vy;
      if(this.y + this.h >= groundY){
        this.y = groundY - this.h;
        this.vy = 0; this.onGround = true;
      }
    },
    draw(){
      ctx.save();
      ctx.scale(-1,1); // 反転描画
      const img = images.penguinRun;
      if(img){ ctx.drawImage(img, 0,0,img.width,img.height, -this.x-this.w, this.y, this.w, this.h); }
      else{ ctx.fillStyle = '#a6f0c5'; ctx.fillRect(-this.x-this.w,this.y,this.w,this.h); }
      ctx.restore();
    }
  };

  const bear = {
    x: 20,
    y: groundY - 120,
    w: 180,
    h: 120,
    draw(){
      const img = images.bear;
      if(img){
        ctx.drawImage(img,0,0,img.width,img.height,this.x,this.y,this.w,this.h);
      }else{
        ctx.fillStyle = '#333'; ctx.fillRect(this.x,this.y,this.w,this.h);
      }
    }
  };

  const obstacles = [];
  function spawnObstacle(){
    const width = 40 + Math.random()*40;
    const height = 30 + Math.random()*80;
    obstacles.push({ x: VW + 20, y: groundY - height, w: width, h: height });
  }
  function updateObstacles(){
    for(const o of obstacles){ o.x -= speed; }
    while(obstacles.length && obstacles[0].x + obstacles[0].w < -20){ obstacles.shift(); }
    if((perf|0) % 90 === 0){ spawnObstacle(); }
  }
  function drawObstacles(){
    for(const o of obstacles){ ctx.fillStyle='#8b9bb8'; ctx.fillRect(o.x,o.y,o.w,o.h); }
  }

  function intersects(a,b){
    return !(a.x+a.w<b.x || a.x>b.x+b.w || a.y+a.h<b.y || a.y>b.y+b.h);
  }

  function doJump(){ if(state==='home'){ startGame(); } else if(state==='playing'){ player.jump(); } else if(state==='gameover'){ goHome(); } }
  window.addEventListener('touchstart',(e)=>{e.preventDefault();doJump();},{passive:false});
  window.addEventListener('mousedown',()=>{doJump();});
  window.addEventListener('keydown',(e)=>{if(e.code==='Space'||e.code==='ArrowUp'){e.preventDefault();doJump();}});

  function drawHUD(){
    ctx.textAlign='left'; ctx.fillStyle='#fff'; ctx.font='20px sans-serif';
    ctx.fillText(`SCORE ${score|0}`,16,34);
    ctx.fillText(`LIFE ${lives}`,16,60);
  }

  function drawGameOver(){
    ctx.fillStyle='rgba(0,0,0,.55)';ctx.fillRect(0,0,VW,VH);
    if(images.gotHit){ ctx.drawImage(images.gotHit,VW/2-240,80,480,270); }
    ctx.textAlign='center'; ctx.fillStyle='#fff'; ctx.font='60px sans-serif'; ctx.fillText('GAME OVER',VW/2,64);
    ctx.font='28px sans-serif'; ctx.fillText('タップでホームへ',VW/2,VH-42);
    ctx.fillText(`SCORE ${score|0}`,VW/2,VH-80);
  }

  function startGame(){
    state='playing'; scroll=0; speed=6; score=0; perf=0; lives=3;
    player.x=200; player.y=groundY-player.h; player.vy=0; player.onGround=true; player.stunned=false;
    bear.x=20; bear.y=groundY-bear.h;
    obstacles.length=0;
  }
  function goHome(){ state='home'; }
  function toGameOver(){ state='gameover'; }

  let perf=0;
  function tick(ts){
    const dt=ts-last; last=ts; perf+=dt||16.7;
    clear();
    if(state==='loading'){
      drawBG(); ctx.fillStyle='#fff'; ctx.textAlign='center'; ctx.fillText('読み込み中…',VW/2,VH/2);
    } else if(state==='home'){
      drawBG(); ctx.fillStyle='#fff'; ctx.textAlign='center'; ctx.font='56px sans-serif'; ctx.fillText('わいちゃんRUN',VW/2,60);
      if(images.homeImage){ ctx.drawImage(images.homeImage,VW/2-210,90,420,240); }
      ctx.font='28px sans-serif'; ctx.fillText('START',VW/2,VH-100);
    } else if(state==='playing'){
      scroll+=speed; score+=speed*0.4; speed=Math.min(14,speed+0.0009);
      drawBG(); updateObstacles(); drawObstacles();
      player.update(); player.draw(); bear.draw();
      for(const o of obstacles){
        if(intersects(player,o)){
          if(!player.stunned){
            lives--; player.stunned=true; player.stunTimer=60; // 1秒くらい動けない
            if(lives<=0){ toGameOver(); }
          }
        }
      }
      drawHUD();
    } else if(state==='gameover'){
      drawBG(); drawObstacles(); player.draw(); bear.draw(); drawGameOver();
    }
    requestAnimationFrame(tick);
  }

  Promise.all([
    loadImage(ASSETS.penguinRun).then(img=>images.penguinRun=img),
    loadImage(ASSETS.bear).then(img=>images.bear=img),
    loadImage(ASSETS.gotHit).then(img=>images.gotHit=img),
    loadImage(ASSETS.homeImage).then(img=>images.homeImage=img)
  ]).then(()=>{ state='home'; requestAnimationFrame(tick); });
})();
</script>
</body>
</html>
